# Grafana Helm Chart Values
# Official Grafana Helm Chart: https://grafana.github.io/helm-charts
# Official Documentation: https://grafana.com/docs/grafana/latest/setup-grafana/installation/helm/

# ⚠️ IMPORTANTE - CONFIGURAÇÃO SEM STORAGE PERSISTENTE
# Esta configuração foi ajustada para funcionar SEM Persistent Volumes devido à
# ausência do EBS CSI Driver addon no cluster EKS.
#
# IMPLICAÇÕES:
# - Os dados do Grafana (dashboards customizados, configurações de usuário) serão
#   PERDIDOS quando o pod for reiniciado ou recriado
# - Dashboards provisionados via ConfigMaps e sidecar serão mantidos
# - Datasources configurados via Helm values serão mantidos
# - Configurações de autenticação OAuth permanecerão ativas
# - Usuários e suas permissões gerenciadas pelo Cognito não serão afetados
#
# SOLUÇÃO PERMANENTE:
# Quando o EBS CSI Driver for habilitado, altere:
#   persistence.enabled: true
#   persistence.storageClassName: gp2 (ou gp3)
#   persistence.size: 10Gi

# Global settings
global:
  domain: ${grafana_subdomain}.${domain_name}

# Replicas
replicas: 1

# Admin user configuration
adminUser: admin
# adminPassword removed - will be auto-generated by Helm
# Access via: kubectl get secret --namespace monitoring grafana -o jsonpath="{.data.admin-password}" | base64 --decode

# Resource configuration
resources:
  requests:
    cpu: ${grafana_resources.requests.cpu}
    memory: ${grafana_resources.requests.memory}
  limits:
    cpu: ${grafana_resources.limits.cpu}
    memory: ${grafana_resources.limits.memory}

# Environment variables from secrets
envFromSecret: grafana-oauth-secret

# Persistence configuration
# IMPORTANTE: Desabilitado para evitar dependência do EBS CSI Driver
# Os dados do Grafana serão perdidos ao reiniciar o pod, mas as configurações
# via Kubernetes (ConfigMaps, Secrets) serão mantidas
persistence:
  enabled: false
  # type: emptyDir não é suportado diretamente pelo chart
  # Para usar storage temporário, desabilite persistence completamente

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 3000

# Ingress configuration
ingress:
  enabled: true
  ingressClassName: nginx-public
  annotations:
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
    nginx.ingress.kubernetes.io/cors-expose-headers: "*, X-CustomResponseHeader"
  hosts:
    - ${grafana_subdomain}.${domain_name}

# Grafana configuration
grafana.ini:
  server:
    domain: ${grafana_subdomain}.${domain_name}
    root_url: https://${grafana_subdomain}.${domain_name}
    serve_from_sub_path: false

  # Security settings
  security:
    admin_user: admin
    # admin_password removed - auto-generated by Helm for security
    allow_embedding: false
    cookie_secure: false
    cookie_samesite: lax

  # Authentication settings
  auth:
    disable_login_form: false
    disable_signout_menu: false
    oauth_auto_login: true

  # Generic OAuth settings for Cognito
  auth.generic_oauth:
    enabled: true
    name: OptimusFrame SSO
    client_id: ${cognito_client_id}
    # client_secret moved to envFromSecret for security
    scopes: openid email profile
    auth_url: https://${user_pool_name}.auth.${cognito_region}.amazoncognito.com/oauth2/authorize
    token_url: https://${user_pool_name}.auth.${cognito_region}.amazoncognito.com/oauth2/token
    api_url: https://${user_pool_name}.auth.${cognito_region}.amazoncognito.com/oauth2/userInfo
    team_ids:
    allowed_organizations:
    allow_sign_up: true
    auto_login: false
    use_pkce: true
    use_refresh_token: true
    # Esta linha define a lógica para atribuição de função (role) de usuário no Grafana com base nos grupos aos quais o usuário pertence.
    # Ela verifica se o usuário está no grupo de administradores do sistema (${system_admin_group_name}) ou no grupo de administradores (${admin_group_name}).
    # Se o usuário pertencer a qualquer um desses grupos, ele recebe a função "Admin". Caso contrário, recebe a função "Viewer".
    # A expressão utiliza operadores lógicos para realizar as verificações e atribuições de forma condicional.
    role_attribute_path: contains(groups[*], '${system_admin_group_name}') && 'Admin' || contains(groups[*], '${admin_group_name}') && 'Admin'
    role_attribute_strict: false
    allow_assign_grafana_admin: true
    skip_org_role_sync: false

  # User settings
  users:
    allow_sign_up: false
    auto_assign_org: true
    auto_assign_org_id: 1
    auto_assign_org_role: Admin
    viewers_can_edit: false
    editors_can_admin: false

  # Analytics
  analytics:
    reporting_enabled: false
    check_for_updates: false

  # Snapshots
  snapshots:
    external_enabled: false

  # Logging
  log:
    mode: console
    level: info

# Enable metrics for monitoring
metrics:
  enabled: true
  service:
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "3000"
      prometheus.io/path: "/metrics"

# ServiceMonitor for Prometheus Operator
# IMPORTANTE: Desabilitado por padrão pois requer Prometheus Operator CRDs instalados
# Para habilitar: instale o Prometheus Operator primeiro e altere enabled para true
serviceMonitor:
  enabled: false # ⚠️ Requer prometheus-operator CRDs (monitoring.coreos.com/v1)
  labels:
    app: grafana
  interval: 30s
  path: /metrics

# Dashboard provisioning via sidecar (ConfigMaps)
# Os dashboards serão carregados dinamicamente via ConfigMaps com label grafana_dashboard=1
dashboardProviders:
  dashboardproviders.yaml:
    apiVersion: 1
    providers:
      - name: "default"
        orgId: 1
        folder: ""
        type: file
        disableDeletion: false
        editable: true
        options:
          path: /tmp/dashboards

# Dashboards embutidos no Helm chart
# Estes serão baixados do Grafana.com durante a instalação do chart
dashboards:
  default:
    # Kubernetes cluster monitoring dashboard
    k8s-cluster-overview:
      gnetId: 7249
      revision: 1
      datasource: Prometheus
    # Kubernetes pods monitoring
    k8s-pods:
      gnetId: 6417
      revision: 1
      datasource: Prometheus
    # Kubernetes nodes
    k8s-nodes:
      gnetId: 8588
      revision: 1
      datasource: Prometheus
    # Node Exporter Full dashboard
    node-exporter-full:
      gnetId: 1860
      revision: 37
      datasource: Prometheus

# RBAC configuration
rbac:
  create: true
  pspEnabled: false

# Service Account
serviceAccount:
  create: true
  name: grafana
  annotations: {}

# Pod Security Context
securityContext:
  runAsNonRoot: true
  runAsUser: 472
  fsGroup: 472

# Container Security Context
# Ajustado para funcionar sem volume persistente
containerSecurityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 472
  runAsGroup: 472

# Environment variables
env:
  GF_EXPLORE_ENABLED: true
  GF_PANELS_DISABLE_SANITIZE_HTML: true
  GF_LOG_FILTERS: rendering:debug
  GF_DATE_FORMATS_INTERVAL_SECOND: HH:mm:ss
  GF_DATE_FORMATS_INTERVAL_MINUTE: HH:mm
  GF_DATE_FORMATS_INTERVAL_HOUR: MM/DD HH:mm
  GF_DATE_FORMATS_INTERVAL_DAY: MM/DD
  GF_DATE_FORMATS_INTERVAL_MONTH: YYYY-MM
  GF_DATE_FORMATS_INTERVAL_YEAR: YYYY

# NOTA: Não é necessário adicionar extraEmptyDirMounts para /var/lib/grafana
# Quando persistence: false, o chart automaticamente cria um volume emptyDir
# para os diretórios necessários do Grafana

# Init containers
# IMPORTANTE: Desabilitado quando persistence está desabilitada
# initChownData serve para ajustar permissões de volumes persistentes
initChownData:
  enabled: false

# Sidecar for dynamic dashboard loading
sidecar:
  dashboards:
    enabled: true
    label: grafana_dashboard
    labelValue: "1"
    searchNamespace: ALL
    provider:
      allowUiUpdates: false
  datasources:
    enabled: false # Desabilitado - datasources provisionados via Terraform
    label: grafana_datasource
    labelValue: "1"
    searchNamespace: ALL

# Plugin installation
plugins:
  - grafana-piechart-panel
  - grafana-worldmap-panel
  - grafana-clock-panel
  - grafana-simple-json-datasource

# Notifiers for alerting (can be configured later)
notifiers: {}

# Image pull secrets (if needed for private registries)
imagePullSecrets: []

# Tolerations and node affinity (if needed)
tolerations: []
affinity: {}
nodeSelector: {}

# Pod annotations
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "3000"
  prometheus.io/path: "/metrics"

# Additional labels
podLabels:
  app: grafana
  component: grafana
  part-of: monitoring
